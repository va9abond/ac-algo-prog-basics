= Algorithms and Programming Basics
Rustem Sirazetdinov <avesirazetdinov@gmail.com>
:sectnums:
:toc:



== Task List

. link:tasks/1-cross.jl[1-cross]
+
ДАНО:: Робот находится в произвольной клетке ограниченного прямоугольного
    поля без внутренних перегородок и маркеров.
+
РЕЗУЛЬТАТ:: Робот — в исходном положении в центре прямого креста из маркеров,
расставленных вплоть до внешней рамки (в клетке с роботом маркера
нет).

. link:tasks/2-mark_perimeter.jl[2-mark_perimeter]
+
ДАНО:: Робот - в произвольной клетке поля (без внутренних перегородок и маркеров)
+
РЕЗУЛЬТАТ:: Робот - в исходном положении, и все клетки по
периметру внешней рамки промаркированы.

. link:tasks/3-mark_whole_field.jl[3-mark_whole_field]
+
ДАНО:: Робот - в произвольной клетке ограниченного прямоугольного поля
+
РЕЗУЛЬТАТ:: Робот - в исходном положении, и все клетки поля
промаркированы.

. link:tasks/4-slanting_cross.jl[4-slanting_cross]
+
ДАНО:: Робот находится в произвольной клетке ограниченного
прямоугольного поля без внутренних перегородок и маркеров.
+
РЕЗУЛЬТАТ:: Робот — в исходном положении в центре косого креста из
маркеров, расставленных вплоть до внешней рамки.

. link:tasks/5-mark_around_inner_border.jl[5-mark_around_inner_border]
+
ДАНО:: На ограниченном внешней прямоугольной рамкой поле имеется ровно
одна внутренняя перегородка в форме прямоугольника. Робот - в
произвольной клетке поля между внешней и внутренней перегородками.
+
РЕЗУЛЬТАТ:: Робот - в исходном положении и по всему периметру
внутренней, как внутренней, так и внешней, перегородки поставлены
маркеры.

. link:tasks/6a-mark_perimeter_borders.jl[6a-mark_perimeter_borders] / 
link:tasks/6b-mark_in_front_of_start_pos.jl[6b-mark_in_front_of_start_pos]
+
ДАНО:: Робот - в произвольной клетке ограниченного прямоугольного
поля, на котором могут находиться также внутренние прямоугольные
перегородки (все перегородки изолированы друг от друга, прямоугольники
могут вырождаться в отрезки)
+
РЕЗУЛЬТАТ:: Робот - в исходном положении и
- по всему периметру внешней рамки стоят маркеры;
- маркеры не во всех клетках периметра, а только в 4-х позициях -
  напротив исходного положения робота.

. link:tasks/7-bypass_plain.jl[7-bypass_plain]
+
ДАНО:: Робот - рядом с горизонтальной бесконечно продолжающейся в обе
стороны перегородкой (под ней), в которой имеется проход шириной в
одну клетку.
+
РЕЗУЛЬТАТ:: Робот - в клетке под проходом

. link:tasks/8-find_marker_spiral.jl[8-find_marker_spiral]
+
ДАНО:: Где-то на неограниченном со всех сторон поле без внутренних
перегородок имеется единственный маркер. Робот - в произвольной клетке
этого поля.
+
РЕЗУЛЬТАТ:: Робот - в клетке с маркером.

. link:tasks/9-mark_all_chess.jl[9-mark_all_chess]
+
ДАНО:: Робот - в произвольной клетке ограниченного прямоугольного поля
(без внутренних перегородок)
+
РЕЗУЛЬТАТ:: Робот - в исходном положении, на всем поле расставлены
маркеры в шахматном порядке, причем так, чтобы в клетке с роботом
находился маркер

. UNDONE
+
ДАНО:: Робот - в произвольной клетке ограниченного прямоугольного поля
(без внутренних перегородок)
+
РЕЗУЛЬТАТ:: Робот - в исходном положении, и на всем поле расставлены
маркеры в шахматном порядке клетками размера N*N (N-параметр функции),
начиная с юго-западного угла.

. link:tasks/11-count_plain_borders.jl[11-count_plain_borders]
+
ДАНО:: Робот - в произвольной клетке ограниченного прямоугольного
поля, на поле расставлены горизонтальные перегородки различной длины
(перегородки длиной в несколько клеток, считаются одной перегородкой),
не касающиеся внешней рамки.
+
РЕЗУЛЬТАТ:: Робот — в исходном положении, подсчитано и возвращено
число всех перегородок на поле.

. link:tasks/12-count_plain_borders_general.jl[12-count_plain_borders_general]
+
Отличается от предыдущей задачи тем, что если в перегородке имеются
разрывы не более одной клетки каждый, то такая перегородка считается
одной перегородкой.

. link:tasks/13-mark_all_chess_general.jl[13-mark_all_chess_general]
+
Решить задачу 9 с использованием обобщённой функции
+
----
snake!(robot,
    (move_side, next_row_side)::NTuple{2,HorizonSide} = (Ost,Nord)
)
----

. link:tasks/14-mark_all_chess_general_borders.jl[14-mark_all_chess_general_border]
+
Решить задачу 13, но при условии наличия на поле простых внутренних
перегородок.
Под простыми перегородками мы понимаем изолированные
прямолинейные или прямоугольные перегородки.

. link:task/15-slanting_cross_simple_borders.jl[15-slanting_cross_simple_borders]
+
Решить задачу 4, но при условии наличия на поле простых внутренних
перегородок.

. link:tasks/7-bypass_plain.jl[7-bypass_plain]
+
Решить задачу 7 с использованием обобщённой функции
+
-----
shuttle!(stop_condition::Function, robot, side)
-----

. link:tasks/8-find_marker_spiral.jl[8-find_marker_spiral]
+
Решить задачу 8 с использованием обобщённой функции
+
----
spiral!(stop_condition::Function, robot)
----

. link:tasks/18-find_marker_spiral_borders.jl[18-find_marker_spiral_borders]
+
Решить предыдущую задачу, но при дополнительном условии:
+
.. На поле имеются внутренние изолированные прямолинейные
перегородки конечной длины (только прямолинейных, прямоугольных
перегородок нет);
+
.. Некоторые из прямолинейных перегородок могут быть
полубесконечными.
+
link:tasks/18-find_marker_spiral_borders_path_back.jl[18-find_marker_spiral_borders_path_back]

. link:tasks/19-till_the_end_recursively.jl[19-till_the_end_recursively]
+
Написать рекурсивную функцию, перемещающую робота до упора в
заданном направлении.

. link:tasks/20-till_the_end_recursively_marker.jl[20-till_the_end_recursively_marker]
+
Написать рекурсивную функцию, перемещающую робота до упора в заданном
направлении, ставящую возле перегородки маркер и возвращающую робота в
исходное положение.

. link:tasks/21-bypass_plane_border_recursively.jl[21-bypass_plane_border_recursively]
+
Написать рекурсивную функцию, перемещающую робота в соседнюю
клетку в заданном направлении, при этом на пути робота может находиться
изолированная прямолинейная перегородка конечной длины.

. link:tasks/22-double_dist-a.jl[22-double_dist-a]
+
Написать рекурсивную функцию, перемещающую робота на расстояние
вдвое большее исходного расстояния от перегородки, находящейся с
заданного направления (предполагается, что размеры поля позволяют
это сделать).
+
.. link:tasks/22-double_dist-b.jl[22-double_dist-b]
+
Доработать эту функцию таким образом, чтобы она возвращала значение
`true`, в случае, если размеры поля позволяют удвоить расстояние, или -
значение `false`, в противном случае (в этом случае робот должен
быть перемещен на максимально возможное расстояние).
+
.. link:tasks/22-double_dist-c.jl[22-double_dist-c]
+
Как при этом можно было бы сделать так, чтобы в случае невозможности
переместить робота на удвоенное расстояние, в результате робот
оставался бы в исходном положении?

. Написать рекурсивную функцию, перемещающую робота в позицию,
симметричную по отношению к перегородке, находящейся с заданного
направления, т.е. требуется, чтобы в результате робот оказался на расстоянии от
противоположной перегородки равном расстоянию до заданной перегородки.

. Написать рекурсивную функцию, перемещающую робота на расстояние
от перегородки с заданного направления вдвое меньшее исходного.
Указание: воспользоваться косвенной рекурсией.

. Написать рекурсивную функцию, перемещающую робота в заданном
направлении до упора и расставляющую маркеры в шахматном порядке,
a) начиная с установки маркера;
б) начиная без установки маркера (в стартовой клетке).
Указание: воспользоваться косвенной рекурсией

. Написать рекурсивную функцию, суммирующую все элементы
заданного вектора (реализовать хвостовую рекурсию).

. Написать функцию, возвращающую значение n-го члена
последовательности Фибоначчи (1, 1, 2, 3, 5, 8, ...)
а) без использования рекурсии;
б) с использованием рекурсии;
практически убедиться, что наивная рекурсивная реализация такой функции
будет крайне неэффективна в вычислительном отношении.
в) с использованием рекурсии и с мемоизацией;
убедиться, что полученный алгоритм будет достаточно эффективен в
вычислительном отношении.

. Написать функцию, маркирующую все клетки лабиринта произвольной
формы, ограниченного перегородками, и возвращающую робота в исходное
положение.

. Написать функцию, расставляющие маркеры в каждой клетке внутри
произвольного замкнутого лабиринта, ограниченного
а) маркерами,
б) перегородками,
и возвращающую робота в исходное положение.
**Указание**: воспользоваться рекурсией.

. Написать функцию, расставляющие маркеры в шахматном порядке,
начиная с исходной клетки внутри произвольного замкнутого лабиринта,
ограниченного перегородками, и возвращающего робота в исходное положение.
**Указания**:
1) воспользоваться рекурсивным алгоритмом обхода поля;
2) спроектировать и использовать робота специального типа, ставящего
маркеры в шахматном порядке

. Написать функцию, расставляющие маркеры в форме косого креста с
центром в исходном положении робота внутри произвольного замкнутого
лабиринта (граница которого не обязательно односвязная, т.е. она может
ограничивать область поля с «дырами» внутри внешней границы),
ограниченного перегородками, и возвращающего робота в исходное положение.
**Указания**:
1) Воспользоваться рекурсивным алгоритмом обхода поля, и спроектировать
робота специального типа, ставящего маркеры только в "диагональных"
клетках.
2) Решить задачу без использования рекурсии. Для этого воспользоваться
параметрическим типом EdgeRobot{CoordsRobot} (см. лекцию 10).

. Написать рекурсивную функцию, выводящую на экран информацию об
  иерархии типов языка Julia.
**Указания**:
1) научиться пользоваться встроенными функциями `supertype` и
`subtypes`.
2) вывод всех подтипов очередного типа печатать с отступом вправо на 4
позиции (для этого у рекурсивной функции можно предусмотреть специальный
параметр, через который можно будет передавать величину отступа при выводе
очередного списка подтипов на печать).

. Написать функцию, осуществляющую поиск клетки в конечном
лабиринте, ограниченном перегородками с максимальной температурой, и
перемещающей робота в эту клетку.

. Разработать специальный пользовательский тип (специальный тип
робота), позволяющий перемещать робота вдоль перегородки произвольной
формы (влево или вправо, по отношению к направлению на перегородку) на один
шаг (на одну клетку). Для задания направления перемещения вдоль границы
воспользоваться следующим определением перечисления
@enum Оrientation Positive=0 Negaive=1.

. Для разработанного в пункте 32 типа написать новые методы
обобщенной функции along! (перемещающую робота вдоль перегородки в
заданном направлении типа Оrientation на заданное число шагов, или до
выполнения заданного условия останова, или до выполнения заданного условия
останова, но не более чем на заданное число шагов, или до выполнения заданного
условия и возвращающую число сделанных шагов).

. Для разработанного в пункте 32 типа написать обобщенную функцию,
осуществляющую движение вокруг перегородки произвольной формы в
заданном направлении с возвратом в исходную позицию.
**Указания**:
1. Воспользоваться типом CoordsRobot.
2. Учесть, что для обнаружения факта возврата робота в исходную
клетку (при круговом движении в одну сторону) в общем случае недостаточно
проверять равенство текущих координат робота с координатами стартовой
клетки, тут также необходимо учитывать ещё, в какую сторону горизонта
движется робот (при завершении круга направление движения робота должно
совпасть с его стартовым направлением).

. Робот находится рядом с границей лабиринта произвольной формы.
Требуется замаркировать все клетки по периметру лабиринта (со стороны
робота).

. Найти координаты самой северной приграничной клетки (по отношению
к стартовому положению робота) при перемещении по кругу вдоль границы
произвольной формы.

. Робот находится рядом с границей лабиринта произвольной формы.
Требуется определить где он находится, внутри лабиринта или снаружи.

. Робот находится снаружи лабиринта произвольной формы, рядом с его
границей. Требуется найти площадь лабиринта (выраженную числом
внутренних клеток).

. Робот находится внутри лабиринта произвольной формы, внутри
которого имеются другие изолированные (внешним образом) лабиринты тоже
произвольной формы. Требуется посчитать число внутренних лабиринтов (число
внутренних изолированных перегородок). При этом имеется в виду, что робот
находится где-то в промежутке между внешним и внутренними лабиринтами.
**Указание**. Сначала можно рассмотреть чуть более простой случай, когда
внешний лабиринт представляет собой перегородку прямоугольной формы. Это
допущение позволит легко обойтись без рекурсии.


== Q&As

[qanda]
Две реализации функции `cross!`. Что лучше?::
Итак, у меня есть две реализации функции `cross!`.
+
.Some Ruby code
[source,ruby]
----
require 'sinatra'

get '/hi' do
  "Hello World!"
end
----
